#!/bin/sh -e
#---------------------------------------------------------------------
# run procenv with every argument
#---------------------------------------------------------------------

script_name=${0##*/}

# Use full path to build binary
procenv="@abs_builddir@/procenv"

template="/tmp/${script_name}.XXXXXXXXXX"

xml_checker=xmlwf
json_checker=json_pp

die ()
{
	local msg="$*"
	echo "ERROR: $msg" >&2
	exit 1
}

msg ()
{
	local msg="$*"
	echo "INFO: $msg"
}

run_command()
{
	local cmdline="$*"

	[ -z "$cmdline" ] && die "need command"

	[ -n "$PROCENV_TEST_DEBUG" ] && msg "Running: '$cmdline'"

	{ eval "$cmdline"; ret=$?; } || :
	[ "$ret" -eq 0 ] || die "command '$cmdline' failed (ret=$ret)"
}

[ -f "$procenv" ] || die "cannot find binary: $procenv"

#---------------------------------------------------------------------
# Init

for cmd in $xml_checker $json_checker
do
	command -v "$cmd" >/dev/null 2>&1 || die "need command '$cmd'"
done

#---------------------------------------------------------------------
msg "Ensure $procenv runs with no errors"

stdout=$(mktemp "$template")
stderr=$(mktemp "$template")
$procenv 1>"$stdout" 2>"$stderr"
rm -f "$stdout" "$stderr"

# Save all sections that are displayed by default for later checks
sections=$($procenv|grep "^[^ ].*:$")

remaining_file=$(mktemp "$template")
echo "$sections" > "$remaining_file"

# pathconf cannot be handled below as it is indented under the mount
# output, so just check we can find some evidence of it being displayed.
$procenv|egrep -q "\<pathconf\>:" || die "Failed to find pathconf"

#---------------------------------------------------------------------
msg "Ensure --file=<file> works"

out=$(mktemp "$template")
stdout=$(mktemp "$template")
stderr=$(mktemp "$template")
$procenv --file="$out" 1>"$stdout" 2>"$stderr"

[ -s "$stdout" ] && die "Unexpected stdout output: $stdout"
[ -s "$stderr" ] && die "Unexpected stderr output: $stderr"
[ -s "$out" ] || die "Expected output in file $out"

rm "$out"
rm -f "$stdout" "$stderr"

#---------------------------------------------------------------------
msg "Ensure --output=stdout works"

stdout=$(mktemp "$template")
stderr=$(mktemp "$template")
$procenv --output=stdout 1>"$stdout" 2>"$stderr"

[ -s "$stdout" ] || die "Expected stdout output in file $stdout"
[ -s "$stderr" ] && die "Unexpected stderr output: $stderr"
rm -f "$stdout" "$stderr"

#---------------------------------------------------------------------
msg "Ensure --output=stderr works"

stdout=$(mktemp "$template")
stderr=$(mktemp "$template")
$procenv --output=stderr 1>"$stdout" 2>"$stderr"

[ -s "$stderr" ] || die "Expected stderr output in file $stderr"
[ -s "$stdout" ] && die "Unexpected stdout output: $stdout"
rm -f "$stdout" "$stderr"

#---------------------------------------------------------------------
msg "Ensure --exec works"

str="hello world"
out=$(mktemp "$template")
stdout=$(mktemp "$template")
stderr=$(mktemp "$template")
$procenv --output=file --file="$out" \
	--exec echo "$str" 1>"$stdout" 2>"$stderr"

[ -s "$out" ] || die "Expected $procenv output in file $out"
[ -s "$stderr" ] && die "Unexpected stderr output in file $stderr"

[ -s "$stdout" ] || die "Expected stdout output in file $stdout"
result=$(cat "$stdout")

[ "$result" != "$str" ] && die \
	"Expected file $stdout to contain '$str', found '$result'"

rm -f "$stdout" "$stderr" "$out"

#---------------------------------------------------------------------
arg='--format=text'
msg "Ensure '$arg' works"

stdout=$(mktemp "$template")
stderr=$(mktemp "$template")
$procenv $arg 1>"$stdout" 2>"$stderr"

[ -s "$stdout" ] || die "Expected stdout output in file $stdout"
[ -s "$stderr" ] && die "Unexpected stderr output in file $stdout"

rm -f "$stdout" "$stderr"

#---------------------------------------------------------------------
arg='--format=crumb'
msg "Ensure '$arg' works"

stdout=$(mktemp "$template")
stderr=$(mktemp "$template")
$procenv $arg 1>"$stdout" 2>"$stderr"

[ -s "$stdout" ] || die "Expected stdout output in file $stdout"
[ -s "$stderr" ] && die "Unexpected stderr output in file $stdout"

rm -f "$stdout" "$stderr"

#---------------------------------------------------------------------
arg='--format=xml'
msg "Ensure '$arg' works"

stdout=$(mktemp "$template")
stderr=$(mktemp "$template")
$procenv $arg 1>"$stdout" 2>"$stderr"

[ -s "$stdout" ] || die "Expected stdout output in file $stdout"
[ -s "$stderr" ] && die "Unexpected stderr output in file $stdout"

[ -z "$($xml_checker "$stdout")" ] || die "XML output not well-formed"

rm -f "$stdout" "$stderr"

#---------------------------------------------------------------------
arg='--format=json'
msg "Ensure '$arg' works"

stdout=$(mktemp "$template")
stderr=$(mktemp "$template")
$procenv $arg 1>"$stdout" 2>"$stderr"

[ -s "$stdout" ] || die "Expected stdout output in file $stdout"
[ -s "$stderr" ] && die "Unexpected stderr output in file $stdout"

json_pp < "$stdout" >/dev/null

rm -f "$stdout" "$stderr"

#---------------------------------------------------------------------
msg "Ensure all documented options produce output"
$procenv --help | grep -- '-[a-zA-Z0-9], --[a-zA-Z][a-zA-Z0-9]*' |\
	cut -d: -f1 | tr ',' '\n' | egrep -v -- '(-h|--help)' |\
	while read arg
do
	stdout=$(mktemp "$template")
	stderr=$(mktemp "$template")

	# No format option
	cmd="$procenv $arg"
	msg "Running '$cmd'"
	run_command "$cmd 1>\"$stdout\" 2>\"$stderr\""

	[ -z "$stdout" ] && die "No stdout output running '$cmd'"
	[ -s "$stderr" ] && die "Unexpected stderr output running '$cmd' ($stderr)"

	# Establish the name of the section
	section=$(head -1 "$stdout"|grep "^[^ ].*:$" || :)
	[ -z "$section" ] && die "No section title found running '$cmd'"

	if [ "$section" != "version:" ]
	then
		# XXX: pathconf has already been handled above.
		if [ "$section" != "pathconf:" ]
		then
			# Check that that same section appears in the
			# default output. If not, we forgot to update
			# dump().
			echo "$sections"|grep -q "^${section}$" || \
			die "Failed to find section '$section' in default $procenv output"
		fi
	fi

	# Remove this section as it's now been handled
	remaining=$(cat "$remaining_file"|grep -v "^${section}$" || :)
	echo "$remaining"> "$remaining_file"

	rm -f "$stdout" "$stderr"

	# Text format
	cmd="$procenv --format=text $arg"
	msg "Running '$cmd'"
	run_command "$cmd 1>\"$stdout\" 2>\"$stderr\""

	[ -z "$stdout" ] && die "No stdout output running '$cmd'"
	[ -s "$stderr" ] && die "Unexpected stderr output running '$cmd' ($stderr)"
	rm -f "$stdout" "$stderr"

	# JSON format
	cmd="$procenv --format=json $arg"
	msg "Running '$cmd'"
	run_command "$cmd 1>\"$stdout\" 2>\"$stderr\""

	[ -z "$stdout" ] && die "No stdout output running '$cmd'"
	[ -s "$stderr" ] && die "Unexpected stderr output running '$cmd' ($stderr)"

	run_command "$json_checker < \"$stdout\" >/dev/null"

	rm -f "$stdout" "$stderr"

	# XML format
	cmd="$procenv --format=xml $arg"
	msg "Running '$cmd'"
	run_command "$cmd 1>\"$stdout\" 2>\"$stderr\""

	[ -z "$stdout" ] && die "No stdout output running '$cmd'"
	[ -s "$stderr" ] && die "Unexpected stderr output running '$cmd' ($stderr)"
	[ -z "$($xml_checker "$stdout")" ] || die "XML output not well-formed"
	rm -f "$stdout" "$stderr"
done

# If there are any remaining sections that were produced by default
# output but which have not been handed by command-line options, we
# forgot to update usage().
msg "Checking for missing arguments"
remaining=$(cat "$remaining_file")

[ -n "$remaining" ] && \
	die "No command-line option found for the following section(s): '$remaining'"

rm -f "$remaining_file"

#---------------------------------------------------------------------
