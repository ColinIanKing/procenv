#!/bin/sh -e
#---------------------------------------------------------------------
# run procenv with every argument
#---------------------------------------------------------------------

script_name=${0##*/}

# Use full path to build binary
procenv="@builddir@/procenv"

template="/tmp/${script_name}.XXXXXXXXXX"

json_tests=0
xml_tests=0

xml_checker=xmlwf
json_checker=json_pp

# XML disallows reliable encoding of control characters. Since the only
# anticipated possible source of such literal control characters is
# environment variables, such tests will be skipped if this variable has
# the value 1.
control_chars_in_env=0

# with random values
non_display_options="
--crumb-separator=.
--file=/tmp/foo
--format=crumb
--indent=7
--indent-char=X
--separator=X
"

lang_list=

die ()
{
	local str="$*"
	echo "ERROR: $str" >&2
	[ -n "$cmd" ] && echo "ERROR: (cmd='$cmd')" >&2
	exit 1
}

warn ()
{
	local str="$*"
	echo "WARNING: $str"
}

debug ()
{
	local str="$*"
	[ -n "$PROCENV_TEST_DEBUG" ] && echo "DEBUG: $str" || :
}

msg ()
{
	local str="$*"
	echo "INFO:LANG=$LANG: $str"
}

run_command()
{
	_run_command success "$1"
}

run_command_expect_fail()
{
	_run_command failure "$1"
}

_run_command()
{
	local expected_outcome="$1"
	local cmdline="$2"

	local failed=0

	[ -z "$cmdline" ] && die "need command"

	debug "Running: '$cmdline'"

	{ eval "$cmdline"; ret=$?; } || :

	if [ "$expected_outcome" = success ]
	then
		[ "$ret" -ne 0 ] && failed=1
	else 
		[ "$ret" -eq 0 ] && failed=1
	fi

	[ "$failed" -eq 1 ] && \
		die "Command '$cmdline' returned $ret but expected $expected_outcome"

	return 0
}

init()
{
	[ -n "$PROCENV_TEST_DISABLE" ] && msg "Tests disabled" && exit 0
    
	[ -f "$procenv" ] || die "cannot find binary: $procenv"

	command -v "$json_checker" >/dev/null 2>&1 && \
		json_tests=1 || warn "no $json_checker - JSON tests disabled"

	command -v "$xml_checker" >/dev/null 2>&1 && \
		xml_tests=1 || warn "no $xml_checker - XML tests disabled"
    
	env | grep -q "[[:cntrl:]]" && control_chars_in_env=1

	# Always test the default locale
	lang_list=C

	if [ -n "$LANG" ] && [ "$LANG" != "C" ]
	then
		lang_list="$lang_list $LANG"
	fi

	msg "language list: '$lang_list'"
}

run_tests()
{
	procenv_version=$($procenv --version|grep "version: [0-9]"|awk '{print $2}')
	[ -n "$procenv_version" ] || die "failed to query procenv version"

	#---------------------------------------------------------------------
	msg "Running tests for language '$LANG'"
	#---------------------------------------------------------------------
	msg "Ensure $procenv runs with no errors"
	
	stdout=$(mktemp "$template")
	stderr=$(mktemp "$template")
	$procenv 1>"$stdout" 2>"$stderr"
	rm -f "$stdout" "$stderr"
	
	# Save all sections that are displayed by default for later checks
	sections=$($procenv|grep "^[a-z0-9][a-z0-9 ]*:$")
	
	remaining_file=$(mktemp "$template")
	echo "$sections" > "$remaining_file"
	
	# pathconf cannot be handled below as it is indented under the mount
	# output, so just check we can find some evidence of it being displayed.
	$procenv|egrep -q "\<pathconf\>:" || die "Failed to find pathconf"
	
	#---------------------------------------------------------------------
	msg "Ensure --file=<file> works"
	
	out=$(mktemp "$template")
	stdout=$(mktemp "$template")
	stderr=$(mktemp "$template")
	cmd="$procenv --file=\"$out\" 1>\"$stdout\" 2>\"$stderr\""
	run_command "$cmd"
	
	[ -s "$stdout" ] && die "Unexpected stdout output: $stdout"
	[ -s "$stderr" ] && die "Unexpected stderr output: $stderr"
	[ -s "$out" ] || die "Expected output in file $out"
	
	rm "$out"
	rm -f "$stdout" "$stderr"
	
	#---------------------------------------------------------------------
	msg "Ensure --output=stdout works"
	
	stdout=$(mktemp "$template")
	stderr=$(mktemp "$template")

	cmd="$procenv --output=stdout 1>\"$stdout\" 2>\"$stderr\""
	run_command "$cmd"
	
	[ -s "$stdout" ] || die "Expected stdout output in file $stdout"
	[ -s "$stderr" ] && die "Unexpected stderr output: $stderr"

	# ensure internal compression is working
	grep -q '^$' "$stdout" && die "Found blank lines in output"

	rm -f "$stdout" "$stderr"
	
	#---------------------------------------------------------------------
	msg "Ensure --output=stderr works"
	
	stdout=$(mktemp "$template")
	stderr=$(mktemp "$template")
	cmd="$procenv --output=stderr 1>\"$stdout\" 2>\"$stderr\""
	run_command "$cmd"
	
	[ -s "$stderr" ] || die "Expected stderr output in file $stderr"
	[ -s "$stdout" ] && die "Unexpected stdout output: $stdout"
	rm -f "$stdout" "$stderr"
	
	#---------------------------------------------------------------------
	msg "Ensure --exec works"
	
	str="hello world"
	out=$(mktemp "$template")
	stdout=$(mktemp "$template")
	stderr=$(mktemp "$template")
	cmd="$procenv --output=file --file=\"$out\" \
		--exec echo \"$str\" 1>\"$stdout\" 2>\"$stderr\""
	run_command "$cmd"

	[ -s "$out" ] || die "Expected $procenv output in file $out"
	[ -s "$stderr" ] && die "Unexpected stderr output in file $stderr"
	[ -s "$stdout" ] || die "Expected stdout output in file $stdout"
	result=$(cat "$stdout")
	
	[ "$result" != "$str" ] && die \
		"Expected file $stdout to contain '$str', found '$result'"
	
	rm -f "$stdout" "$stderr" "$out"
	
	#---------------------------------------------------------------------
	msg "Ensure --exec can exec $procenv"
	
	out=$(mktemp "$template")
	out2=$(mktemp "$template")

	stdout=$(mktemp "$template")
	stderr=$(mktemp "$template")
	cmd="$procenv --output=file --file=\"$out\" \
		--exec -- $procenv --file=\"$out2\" \
		1>\"$stdout\" 2>\"$stderr\""
	run_command "$cmd"

	[ -s "$out" ] || die "Expected $procenv output in file $out"
	[ -s "$out2" ] || die "Expected $procenv output in file $out2"
	[ -s "$stdout" ] && die "Unexpected stdout output in file $stdout"
	[ -s "$stderr" ] && die "Unexpected stderr output in file $stderr"
	
	rm -f "$stdout" "$stderr" "$out" "$out2"
	
	#---------------------------------------------------------------------
	arg='--format=text'
	msg "Ensure '$arg' works"
	
	stdout=$(mktemp "$template")
	stderr=$(mktemp "$template")
	cmd="$procenv $arg 1>\"$stdout\" 2>\"$stderr\""
	run_command "$cmd"
	
	[ -s "$stdout" ] || die "Expected stdout output in file $stdout"
	[ -s "$stderr" ] && die "Unexpected stderr output in file $stdout"
	
	rm -f "$stdout" "$stderr"
	
	#---------------------------------------------------------------------
	arg='--format=crumb'
	msg "Ensure '$arg' works"
	
	stdout=$(mktemp "$template")
	stderr=$(mktemp "$template")
	cmd="$procenv $arg 1>\"$stdout\" 2>\"$stderr\""
	run_command "$cmd"
	
	[ -s "$stdout" ] || die "Expected stdout output in file $stdout"
	[ -s "$stderr" ] && die "Unexpected stderr output in file $stdout"
	
	rm -f "$stdout" "$stderr"
	
	#---------------------------------------------------------------------
	arg='--indent-char'

	for sep in "." ";" "→" "❤"
	do
		opt="${arg}=${sep}"
		msg "Ensure '$opt' works"

		stdout=$(mktemp "$template")
		stderr=$(mktemp "$template")

		cmd="$procenv \"$opt\" \
			--version 1>\"$stdout\" 2>\"$stderr\""
		run_command "$cmd"
	
		[ -s "$stdout" ] || die "Expected stdout output in file $stdout"
		[ -s "$stderr" ] && die "Unexpected stderr output in file $stdout"

		grep -q "^${sep}${sep}version: ${procenv_version}$" "$stdout" ||\
			die "Did not find expected output for arg '$arg'"

		rm -f "$stdout" "$stderr"
	done

	# --indent-char *must* be a single character, so ensure multi-char
	# values are flagged as incorrect.
	for sep in "12" "123" "1234" "→❤" "→❤→" "❤→❤❤"
	do
		opt="${arg}=${sep}"
		msg "Ensure '$opt' works"

		stdout=$(mktemp "$template")
		stderr=$(mktemp "$template")

		cmd="$procenv \"$opt\" \
			--version 1>\"$stdout\" 2>\"$stderr\""
		run_command_expect_fail "$cmd"
	
		[ -s "$stdout" ] && die "Unexpected stdout output in file $stdout"
		[ -s "$stderr" ] || die "Expected stderr output in file $stdout"

		rm -f "$stdout" "$stderr"
	done

	#---------------------------------------------------------------------
	arg='--separator'
	
	# Choose a few common ones, a few UTF-8 ones and a few
	# multi-character ones.
	for sep in "." ";" "→" "❤" "12" "123" "1234" "→❤" "→❤→" "❤→❤❤"
	do
		opt="${arg}=${sep}"
		msg "Ensure '$opt' works"

		stdout=$(mktemp "$template")
		stderr=$(mktemp "$template")

		cmd="$procenv \"$opt\" \
			--version 1>\"$stdout\" 2>\"$stderr\""
		run_command "$cmd"
	
		[ -s "$stdout" ] || die "Expected stdout output in file $stdout"
		[ -s "$stderr" ] && die "Unexpected stderr output in file $stdout"

		grep -q "^  version${sep}${procenv_version}$" "$stdout" ||\
			die "Did not find expected output for arg '$arg'"
	
		rm -f "$stdout" "$stderr"
	done

	#---------------------------------------------------------------------
	arg='--crumb-separator'
	
	# Choose a few common ones, a few UTF-8 ones and a few
	# multi-character ones.
	for sep in "." ";" "→" "❤" "12" "123" "1234" "→❤" "→❤→" "❤→❤❤"
	do
		opt="${arg}=${sep}"
		msg "Ensure '$opt' works"

		stdout=$(mktemp "$template")
		stderr=$(mktemp "$template")

		cmd="$procenv --format=crumb \"$opt\" \
			--separator=\"$sep\" \
			--version 1>\"$stdout\" 2>\"$stderr\""
		run_command "$cmd"
	
		[ -s "$stdout" ] || die "Expected stdout output in file $stdout"
		[ -s "$stderr" ] && die "Unexpected stderr output in file $stdout"

		grep -q "^version${sep}version${sep}${procenv_version}$" "$stdout" ||\
			die "Did not find expected output for arg '$arg'"
	
		rm -f "$stdout" "$stderr"
	done

	#---------------------------------------------------------------------
	
	if [ "$xml_tests" -eq 1 ]
	then
		arg='--format=xml'
		if [ "$control_chars_in_env" -eq 1 ]
		then
			warn "Skipping '$arg' test as control characters found in environment"
		else
			msg "Ensure '$arg' works"
			
			stdout=$(mktemp "$template")
			stderr=$(mktemp "$template")
			cmd="$procenv $arg 1>\"$stdout\" 2>\"$stderr\""
			run_command "$cmd"
			
			[ -s "$stdout" ] || die "Expected stdout output in file $stdout"
			[ -s "$stderr" ] && die "Unexpected stderr output in file $stdout"
			
			[ -z "$($xml_checker "$stdout")" ] || die "XML output not well-formed"
			
			rm -f "$stdout" "$stderr"
		fi
	fi
	
	#---------------------------------------------------------------------
	
	if [ "$json_tests" -eq 1 ]
	then
		arg='--format=json'
		msg "Ensure '$arg' works"
		
		stdout=$(mktemp "$template")
		stderr=$(mktemp "$template")
		cmd="$procenv $arg 1>\"$stdout\" 2>\"$stderr\""
		run_command "$cmd"
		
		[ -s "$stdout" ] || die "Expected stdout output in file $stdout"
		[ -s "$stderr" ] && die "Unexpected stderr output in file $stdout"
		
		$json_checker < "$stdout" >/dev/null
		
		rm -f "$stdout" "$stderr"
	fi
	
	#---------------------------------------------------------------------
	msg "Ensure all documented options produce output"
	$procenv --help | grep -- '-[a-zA-Z0-9], --[a-zA-Z][a-zA-Z0-9]*' |\
		cut -d: -f1 | tr ',' '\n' | egrep -v -- '(-h|--help)' |\
		while read arg
	do
		stdout=$(mktemp "$template")
		stderr=$(mktemp "$template")

		# No format option
		cmd="$procenv $arg"
		msg "Running '$cmd'"
		run_command "$cmd 1>\"$stdout\" 2>\"$stderr\""

		[ -z "$stdout" ] && die "No stdout output running '$cmd'"
		[ -s "$stderr" ] && die "Unexpected stderr output running '$cmd' ($stderr)"

		# Establish the name of the section
		section=$(head -1 "$stdout"|grep "^[^ ].*:$" || :)
		[ -z "$section" ] && die "No section title found running '$cmd'"

		if [ "$section" != "version:" ]
		then
			# XXX: pathconf has already been handled above.
			if [ "$section" != "pathconf:" ]
			then
				# Check that that same section appears in the
				# default output. If not, we forgot to update
				# dump().
				echo "$sections"|grep -q "^${section}$" || \
				die "Failed to find section '$section' in default $procenv output"
			fi
		fi

		# Remove this section as it's now been handled
		remaining=$(cat "$remaining_file"|grep -v "^${section}$" || :)
		echo "$remaining"> "$remaining_file"

		rm -f "$stdout" "$stderr"

		# Text format
		cmd="$procenv --format=text $arg"
		msg "Running '$cmd'"
		run_command "$cmd 1>\"$stdout\" 2>\"$stderr\""

		[ -z "$stdout" ] && die "No stdout output running '$cmd'"
		[ -s "$stderr" ] && die "Unexpected stderr output running '$cmd' ($stderr)"

		if [ "$section" = "capabilities:" ]
		then
			tmp=$(grep 'CAP_LAST_CAP+1' "$stdout"|cut -d: -f2|tr -d ' ' || :)
			# take care to only perform this test on
			# platforms the _have_ capabilities :)
			if [ -n "$tmp" ]
			then
				last=$(expr "$tmp" - 1)
			
				[ -n "$last" ] || die "unable to establish last capability"
				{ grep -q "number: $last" "$stdout"; ret=$?; } || :
				if [ $ret -ne 0 ]
				then
					warn ""
					warn ""
					warn "Found extra capability procenv is not aware of (number $last)"
					warn ""
					warn "Note that this warning will appear if procenv is built on a"
					warn "system which is running a newer kernel than the"
					warn "development environment assumes (for example if built in a"
					warn "chroot for a back-level release of ubuntu)"
					warn ""
					warn "Please check for a newer version of procenv "
					warn "or raise a bug at:"
					warn ""
					warn "    https://bugs.launchpad.net/procenv/+filebug"
					warn ""
					warn ""
				fi
			fi
		fi

		rm -f "$stdout" "$stderr"

		# JSON format
		if [ "$json_tests" -eq 1 ]
		then
			cmd="$procenv --format=json $arg"
			msg "Running '$cmd'"
			run_command "$cmd 1>\"$stdout\" 2>\"$stderr\""

			[ -z "$stdout" ] && die "No stdout output running '$cmd'"
			[ -s "$stderr" ] && die "Unexpected stderr output running '$cmd' ($stderr)"

			run_command "$json_checker < \"$stdout\" >/dev/null"

			rm -f "$stdout" "$stderr"
		fi

		# XML format
		if [ "$xml_tests" -eq 1 ]
		then
			cmd="$procenv --format=xml $arg"
			if [ "$section" = "environment:" -a "$control_chars_in_env" -eq 1 ]
			then
				warn "Skipping '$cmd' as control characters found in environment"
			else
				msg "Running '$cmd'"
				run_command "$cmd 1>\"$stdout\" 2>\"$stderr\""
				[ -z "$stdout" ] && die "No stdout output running '$cmd'"
				[ -s "$stderr" ] && die "Unexpected stderr output running '$cmd' ($stderr)"
				[ -z "$($xml_checker "$stdout")" ] || die "XML output not well-formed"

			fi

			rm -f "$stdout" "$stderr"
		fi
	done

	for arg in $non_display_options
	do
		# XXX: specifying a non-display option _after_
		# specifing a display option used to be a NOP, but
		# is now disallowed as it is non-sensical and
		# the result could be surprising to the user. 
		#
		# We select '--meta' as a random display option.
		msg "Ensure non-display option ('$arg') disallowed after display option ('--meta')"

		stdout=$(mktemp "$template")
		stderr=$(mktemp "$template")
		cmd="$procenv --meta $arg 1>'$stdout' 2>'$stderr'"
		run_command_expect_fail "$cmd"

		[ -s "$stdout" ] && die "Unexpected stdout output in file $stdout"
		[ -s "$stderr" ] || die "Expected stderr output in file $stdout"

		rm -f "$stdout" "$stderr"
	done

	# If there are any remaining sections that were produced by default
	# output but which have not been handed by command-line options, we
	# forgot to update usage().
	msg "Checking for missing arguments"
	remaining=$(cat "$remaining_file")

	[ -n "$remaining" ] && \
		die "No command-line option found for the following section(s): '$remaining'"

	rm -f "$remaining_file"

	msg "Ensure an empty environment is tolerated"
	if command -v env >/dev/null 2>&1
	then
		cmd="env -i $procenv --environment >/dev/null 2>&1"
		run_command "$cmd"
	fi
}

#---------------------------------------------------------------------

init

saved_lang=LANG

for lang in $lang_list
do
	export LANG="$lang"
	run_tests
done

[ -n "$saved_lang" ] && export LANG="$saved_lang"
#---------------------------------------------------------------------
